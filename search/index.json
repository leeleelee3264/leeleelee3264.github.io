[{"content":"\nCA와 CA에서 Digital Certificate을 발급받아서 적용하는 방법에 대해 설명한다.\nIndex\nCA CA에서 인증서 생성하기 인증서 적용하기 Chain of Trust (plus) 인증서가 사용되는 프로세스 모식도 CA CA는 신뢰할 수 있는 기관에 의해 운영되는데, 주요 업무는 공개키 등록 시 본인 인증과 X.509와 같은 디지털 인증서 생성 및 발생 등이 있다.\nCA의 필요성 공개키와 비밀키만을 이용해 암호화는 수행하면 보안에 매우 취약해진다. [Picture 1] 에서 해커가 사용자 B에게 해커의 공개키를 사용하여 데이터를 보낼 경우 사용자 B는 사용자 A가 보낸 데이터라착각할 수 있다. 이와 같은 해커의 공격 방식을 MTM(Man in the Middle Attack)이라고 한다. 이와 같은 취약점을 해결하기 위해 CA(Certificate Authority) 라는 인증 노드를 사용하게 된다.\n[Picture 1] Man in Middle Attack\nPKI에서 CA가 사용되는 과정 사용자 A가 자신의 공개키를 CA에 등록한다. (본인 인증을 거친다) 사용자 B가 사용자 A의 공개키가 필요할 경우 CA에 가서 사용자 A의 공개키를 요청한다. CA는 사용자 A의 공개키를 암화화하여 사용자 B에게 전달한다. 사용자 B는 해당 공개키만을 사용자 A의 공개키라고 믿게 된다. [Picture 2] PKI에서 CA가 사용되는 과정\nCA 업체 유명한 CA들은 [Picture 3] 같다. CA의 인증서를 대리 구매해주는 서비스들이 외국에도, 한국에도 있지만 직접 CA에 가서 사는 것이 더 좋다. CA에 직접 가서 구매했을 때 QnA나 대응도 더 빠르고, 자세하며 나중에 인증서를 관리할 때에도 더 편했다.\n[Picture 3] 유명한 CA\nCA에서 인증서 생성하기 CA에서 인증서를 생성하기 위해서는 SAN과 CSR을 제출해야 한다. CA 업체에 따라서 추가 서류를 제출해야 할 수 있으니 발급 전에 확인해야 한다.\nSAN Subject Alternative Name 의 약자이다. Optional 이고, 선택한 인증서의 가격에 따라서 보장하는 SAN의 개수에도 차이가 있다. 하나의 인증서로 여러개의 FQDN (Fully Qualified Domain Name)를 보장할 수 있다. 하나의 IP로 향햐는 도메인이 여러개가 있을 때 자주 사용이 된다. SAN 예시\nwww.digicert.com knowledge.digicert.com www.thawte.com CSR Certificate signing request 의 약자이다. CA에서 certificate 발급받기 위해 보내는 메세지이다. 가장 많이 사용되는 포맷은 PKCS #10이다. CSR 을 만들기 전에 PrivateKey를 만드는데, 이 PrivateKey가 바로 PKI에서 사용되는 그 PrivateKey로 아무한테도 노출하면 안된다. [gogetssl] 처럼 인증서 중간 유통 업체들이 때때로 CSR과 PrivateKey를 사용자에게 주기도 한다. OpenSSL로 CSR 생성하기 openssl req -new -newkey rsa:2048 -sha256 -nodes -keyout server.key -out server.csr Private key을 생성한다. 생성한 Private key를 사용하여 CSR을 생성한다. CSR을 생성할 때 [Picture 4] 에 대한 정보를 입력해야 한다. [Picture 4] CSR 입력 사항\nCommon Name SAN이 나오고 나서부터 Common Name은 실제적인 효력 보다는 과거의 레거시 형태로 남아있다. 이번에도 CSR을 작성할 때 OV를 만들어야 하기 때문에 Common Name에 도메인을 쓰지 않고 회사 이름을 넣었다. Comman Name에 도메인을 넣는다면 인증서가 설치되는 서버의 이름과 정확하게 매치해야 한다. 만약 서브 도메인을 위해 인증서를 발급했을 경우에는 full 서브도메인을 정확하게 명시해줘야한다.\nCommon Name 예시\n도메인: mydomain.com 서브 도메인: www common name: www.domain.com Common Name vs SAN common name은 단 하나의 엔트리만 입력을 할 수 있다. wildcard 또는 non-wildcard 이라도 단 하나만 입력을 할수 있다는 것은 변함이 없다 SAN은 common name의 이런 제약을 없애기 위해 생겨났다. SAN이 있기 때문에 multi-name SSL 인증서를 만들 수 있게 되었다. SAN에는 여러가지 값을 넣을 수 있고, Common Name과 중복도 가능하다. SAN이 서버 네임이 일치하는 가 확인하기 위한 유일한 필수 레퍼런스가 되었다. 인증서 관련 커맨드 웹사이트에서 사용하고 있는 인증서 가져오기 echo | openssl s_client -servername google.com -connect google.com:443 |\\\\n sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' \u0026gt; certificate.crt 인증서 열어보기 openssl x509 -in certificate.crt -noout -text [파싱 결과 예시] Certificate: Data: Version: 3 (0x2) Serial Number: 59:43:1c:7c:0e:b1:5c:49:0a:01:4e:60:34:b8:2c:b2 Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Google Trust Services LLC, CN=GTS CA 1C3 Validity Not Before: Apr 25 08:31:18 2022 GMT Not After : Jul 18 08:31:17 2022 GMT Subject: CN=*.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:81:63🆎d3:29:a2:15:6c:ee:b7:43:66:55:c5: 88:6e:70:9b:4d:43:40:66:ea:a4:fc:c0:06:8b:4c: fd:60:23:5f:f7:a0:e4:3c:5a:af:7f:e5:36:63:88: 55:dd:e2:60:41:6c:a1:27:3d:48:fb:2e:6a:21:6d: 01:aa:2e:25:7e ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: 8B:09:31:88:DD:30:A6:59:D3:86:E5:3D:EA:06:6D:F3:C0:25:96:D5 X509v3 Authority Key Identifier: keyid:8A:74:7F:AF:85:CD:EE:95:CD:3D:9C:D0:E2:46:14:F3:71:35:1D:27 Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1c3 CA Issuers - URI:http://pki.goog/repo/certs/gts1c3.der X509v3 Subject Alternative Name: DNS:*.google.com, DNS:*.appengine.google.com, DNS:*.bdn.dev, DNS:*.cloud.google.com, DNS:*.crowdsource.google.com, DNS:*.datacompute.google.com, DNS:*.google.ca, DNS:*.google.cl, DNS:*.google.co.in, DNS:*.google.co.jp, DNS:*.google.co.uk, DNS:*.google.com.ar, DNS:*.google.com.au, DNS:*.google.com.br, DNS:*.google.com.co, DNS:*.google.com.mx, DNS:*.google.com.tr, DNS:*.google.com.vn, DNS:*.google.de, DNS:*.google.es, DNS:*.google.fr, DNS:*.google.hu, DNS:*.google.it, DNS:*.google.nl, DNS:*.google.pl, DNS:*.google.pt, DNS:*.googleadapis.com, DNS:*.googleapis.cn, DNS:*.googlevideo.com, DNS:*.gstatic.cn, DNS:*.gstatic-cn.com, DNS:googlecnapps.cn, DNS:*.googlecnapps.cn, DNS:googleapps-cn.com, DNS:*.googleapps-cn.com, DNS:gkecnapps.cn, DNS:*.gkecnapps.cn, DNS:googledownloads.cn, DNS:*.googledownloads.cn, DNS:recaptcha.net.cn, DNS:*.recaptcha.net.cn, DNS:recaptcha-cn.net, DNS:*.recaptcha-cn.net, DNS:widevine.cn, DNS:*.widevine.cn, DNS:ampproject.org.cn, DNS:*.ampproject.org.cn, DNS:ampproject.net.cn, DNS:*.ampproject.net.cn, DNS:google-analytics-cn.com, DNS:*.google-analytics-cn.com, DNS:googleadservices-cn.com, DNS:*.googleadservices-cn.com, DNS:googlevads-cn.com, DNS:*.googlevads-cn.com, DNS:googleapis-cn.com, DNS:*.googleapis-cn.com, DNS:googleoptimize-cn.com, DNS:*.googleoptimize-cn.com, DNS:doubleclick-cn.net, DNS:*.doubleclick-cn.net, DNS:*.fls.doubleclick-cn.net, DNS:*.g.doubleclick-cn.net, DNS:doubleclick.cn, DNS:*.doubleclick.cn, DNS:*.fls.doubleclick.cn, DNS:*.g.doubleclick.cn, DNS:dartsearch-cn.net, DNS:*.dartsearch-cn.net, DNS:googletraveladservices-cn.com, DNS:*.googletraveladservices-cn.com, DNS:googletagservices-cn.com, DNS:*.googletagservices-cn.com, DNS:googletagmanager-cn.com, DNS:*.googletagmanager-cn.com, DNS:googlesyndication-cn.com, DNS:*.googlesyndication-cn.com, DNS:*.safeframe.googlesyndication-cn.com, DNS:app-measurement-cn.com, DNS:*.app-measurement-cn.com, DNS:gvt1-cn.com, DNS:*.gvt1-cn.com, DNS:gvt2-cn.com, DNS:*.gvt2-cn.com, DNS:2mdn-cn.net, DNS:*.2mdn-cn.net, DNS:googleflights-cn.net, DNS:*.googleflights-cn.net, DNS:admob-cn.com, DNS:*.admob-cn.com, DNS:*.gstatic.com, DNS:*.metric.gstatic.com, DNS:*.gvt1.com, DNS:*.gcpcdn.gvt1.com, DNS:*.gvt2.com, DNS:*.gcp.gvt2.com, DNS:*.url.google.com, DNS:*.youtube-nocookie.com, DNS:*.ytimg.com, DNS:android.com, DNS:*.android.com, DNS:*.flash.android.com, DNS:g.cn, DNS:*.g.cn, DNS:g.co, DNS:*.g.co, DNS:goo.gl, DNS:www.goo.gl, DNS:google-analytics.com, DNS:*.google-analytics.com, DNS:google.com, DNS:googlecommerce.com, DNS:*.googlecommerce.com, DNS:ggpht.cn, DNS:*.ggpht.cn, DNS:urchin.com, DNS:*.urchin.com, DNS:youtu.be, DNS:youtube.com, DNS:*.youtube.com, DNS:youtubeeducation.com, DNS:*.youtubeeducation.com, DNS:youtubekids.com, DNS:*.youtubekids.com, DNS:yt.be, DNS:*.yt.be, DNS:android.clients.google.com, DNS:developer.android.google.cn, DNS:developers.android.google.cn, DNS:source.android.google.cn X509v3 Certificate Policies: Policy: 2.23.140.1.2.1 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crls.pki.goog/gts1c3/QOvJ0N1sT2A.crl 1.3.6.1.4.1.11129.2.4.2: ......v.)y...99!.Vs.c.w..W}.` ..M]\u0026amp;\\%]......`........G0E.!......Y.Z...Z.s#...Al...\u0026amp;......Wi. m.-a..._^,...#....D.tZ.j..W.g....w...^.h.O.l..._N\u0026gt;Z.....j^.;.. D\\*s....`..!.....H0F.!..6:.?...f..m.}%.r..........E.....!..U....G...%.$D.mG.B.. Signature Algorithm: sha256WithRSAEncryption 5c:2b:62:ec:f6:ee:92:0c:28:98:92:af:35:f0:78:5b:75:f2: a2:c5:e9:56:04:da:31:ed:0c:92:16:3a:14:47:f9:60:7d:e4: 36:33:82:13:68:54:37:47:81:f8:b6:0e:66:a7:87:c4:f5:82: ca:58:62:a2:15:63:16:28:5b:8e:bc:e7:18:af:97:a2:f4:92: 92:e3:2f:69:df:ba:7a:80:92:20:14:22:4f:3d:26:69:c6:f8: 90:d1:2c:36:57:0a:5c:20:00:86:d2:bd:52:db:19:39:46:12: b0:65:1d:16:3d:f1:58:4b:d6:19:c0:4b:0d:eb:ad:0b:b9:1c: 03:ad:cb:d1:04:33:a2:2c:b8:33:f6:01:7c:71:7f:e8:8a:32: c1:74:9a:11:f7🆎b9:ff:f8:89:99:f3:f9:50:7b:31:c7:fa: fc:71:d1:c6:f2:b4:d2:82:93:84:ae:d8:eb:55:41:d4:de:9d: 7f:47:44:05:4a:fb:a7:09:b2:89:99:a7:7f:64:13:52:be:73: ee:00:b9:1c:ad:e1:44:48:41:a4:77:55:8d:0a:c8:b0:bb:69: fe:9a:84:a5:cd:2d:a9:61:3b:60:92:e4:43:d6:2b:79:d6:5a: 0d:db:f7:7f:7a:fc:7d:c3:59:e3:7d:d7:47:78:c2:b2:7d:6d: f2:7a:75:49 간단하게 인증서 조회를 하기 위해서는 online parser를 사용할 수 있다. [Online Parser] 파싱의 결과로 나온 field에 대한 설명은 [LeeLee- Digital Certificate] 포스트 에서 더 자세하게 확인할 수 있다.\n인증서 적용하기 CA bundle CA에서 인증서를 발급받으면 end-entity (내 application)의 인증서만 오지 않는다. Root CA의 인증서와 Intermediate 인증서가 함께 오는데 이를 CA bundle이라고 한다. CA bundle은 웹 브라우저 등의 클라이언트와 인증서의 호완성을 높히기 위해서 사용이 된다.\nCA bundle 예시\nRoot CA 인증서 + Intermediate 인증서 + end-entity 인증서 = Certificate Chain [Picture 5] CA bundle\nCA bundle은 *.ca-bundle 확장자의 zip 파일이나 root, intermediate 개별로 주어진다. CA bundle은 클라이언트에게 순차적으로 제공이 되어야 하기 때문에 대게는 CA에서 이미 하나의 bundle을 만들어서 제공해준다. 만약 개별로 주어졌을 경우에는 하나의 ca-bundle로 합쳐야 한다\nCA bundle 합치기 예시\nAddTrustExternalCARoot.crt –\u0026gt; Root CA Certificate COMODORSAAddTrustCA.crt –\u0026gt; Intermediate CA Certificate 1 COMODORSADomainValidationSecureServerCA.crt –\u0026gt; Intermediate CA Certificate 2 yourDomain.crt –\u0026gt; Your SSL Certificate cat ComodoRSADomainValidationSecureServerCA.crt ComodoRSAAddTrustCA.crt AddTrustExternalCARoot.crt \u0026gt; yourDomain.ca-bundle Google CA Bundle 예시\n브라우저의 브라우징 창에 🔒 모양을 누르면 해당 도메인에 대한 인증서의 종류, 상태 등을 볼 수 있는데 google.com의 인증서를 열어봤을 때에도 아래처럼 인증서가 계층을 이루고 있다.\nend-entity 인증서: *.google.com Intermediate 인증서: GTS CA 1C3 Root 인증서: GTS Root R1 [Picture 6] End Entity Certificate\n[Picture 7] Intermediate Certificate\n[Picture 8] Root Certificate\nApply CA Bundle CA bundle을 서버 호스트 어디엔가 다운로드해두었다면 해당 도메인이 등록되어있는 Nginx 등의 웹서버에 CA Bundle가 있는 path를 적어주면 된다. 그럼 알아서 클라이언트에게 CA Bundle을 한꺼번에 넘겨준다. 클라이언트는 이 Bundle을 통해서 end-entity가 믿을 수 있는지 없는지 여부를 결정한다. 이와 같은 과정을 Chain of Trust라고 한다.\n인증서를 서버에 다운로드 하는 것을 ‘installed’ 한다고 표현하는데 실제로는 인증서를 서버에 설치한다기 보다는 특정 디렉터리에 넣어둔다.\nLet’s encrypt 를 인증서로 사용했을 때 Nginx의 configuration 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name www.test.me test.me; location / { try_files $uri $uri/ =404; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/test.me/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/test.me/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } 14번 줄의 의 fullchain.pem이 하나로 압축이 된 CA bundle이다. Let’s encrypt에서는 처음부터 하나로 압축된 ca-bundle을 pem 형식으로 제공해준다.\nChain of Trust CA가 서명한 인증서의 내부 구조 CA가 서명을 end-entity의 인증서에 서명을 하게 되면 end-entity의 인증서에는 아래와 같은 정보가 추가되어 발급된다.\n누가 서명을 했는지 (Issuer name) Issuer의 Digital Signature (Issuer의 Private key로 서명) end-entity (Subject)의 public key [Picture 9] End Entity Certificate 내부 구조\nChain of Trust 과정 Chain of Trust는 브라우저가 신뢰할 수 있는 CA가 Issuer로 있는 인증서를 찾기 까지 모든 layer의 인증서를 탐색하는 과정이라고 생각하면 된다. 다른 말로 신뢰할 수 있는 CA가 발급한 인증서를 증명하는 과정이다. 참고로 브라우저에 Root CA의 인증서를 보내도 대부분은 그 인증서를 쓰지 않고, 브라우저에 이미 자체적으로 저장이 되어있는 Root CA 인증서를 사용한다.\nChain 시나리오 End-entity의 인증서 제출 End-entity는 브라우저가 신뢰할 수 있는 CA가 아니다. End-entity의 Issuer를 확인한다. Intermediate CA가 Issuer로 되어있다. Intermediate CA는 브라우저가 신뢰할 수 있는 CA가 아니다. intermediate CA의 Issuer를 확인한다. Root CA가 Issuer로 되어있다. Root CA는 브라우저가 신뢰할 수 있는 CA다. Root CA의 digital signature를 브라우저가 이미 가지고 있는 Root CA의 public key로 verify한다. Root CA digital signature verify 완료. Root CA → Intermediate CA → End-entity 모두 chain of trust를 통해서 믿을 수 있는 인증서가 된다. [Picture 10] Chain of Trust 과정\nChain 계층 [Picture 11] Chain 계층\nRoot Certificate AKA Trust Anchor 최상단인 Root는 보증해 줄 곳이 없기 때문에 Root CA는 self-signed을 한다. OS, 서드파티 웹 브라우저, 클라이언트 어플리케이션은 Root CA의 인증서를 사전에 설치해둔다. clinet는 chain of trust를 통해서 end-entity가 Root 에 인증이 되었는지 식별할 수 있다. Root가 end-entity에 직접 서명하는 일은 거의 없고, 중간에 하나 또는 여러 개의 Intermediate CA가 서명을 한다. Root의 Private key가 변경이 되었다면 해당 Private key로 발급받은 모든 인증서를 재발급 해야 한다. Intermediate Certificate 거의 모든 SSL 인증서 chain에는 최소 하나의 Intermediate CA가 들어가 있다. Intermediate CA는 Root CA의 신뢰성(trustworthy)의 확장에 필수적인 연결점이고, Root CA와 end-entity에 추가적인 보안 레벨이 된다. End-entity Certificate End-entity의 인증서는 보안, 확장성, CA compliance 등을 제공하지만, 인증서를 발급받은 대상 (subject)의 신뢰성을 보장하지는 못한다. End-entity는 크리티컬한 정보를 CSR에 담아 인증서를 발급해주는 CA(issuer)에게 제출하고, CA가 판단하기에 제출된 정보가 믿을 수 있다면 CA의 Private key로 서명을 한 인증서를 발급해준다. 이 인증서가 verified 또는 signed 되어있지 않다면 SSL connection은 실패한다. (plus)인증서가 사용되는 프로세스 모식도 브라우저와 서버의 request - response 과정 모식도\n[Picture 11] request - response 과정 모식도\n브라우저가 youtube.com 을 요청한다. youtube가 인증서 번들을 브라우저에 제출한다. 브라우저는 자신의 CA public key 리스트로 서버가 제출한 인증서가 정말로 신뢰할 수 있는 CA에 의해 서명되었는지 확인한다. Intermediate CA는 지정된 Root CA가 아니기 때문에 브라우저의 입장에서는 믿을 수 없는 CA다. 제출된 인증서 번들을 타고 올라가서 Root CA까지 간다. 신뢰하기로 한 인증서에 명시되어있는 domain name이나 ip가 맞다면, 서버의 public key를 사용하여 대칭키를 생성하여 서버와 공유한다. 이 대칭키로 connection의 모든 트래픽을 암호화한다. 대칭키를 사용하는 것이 비대칭키를 사용하여 모든 커뮤니케이션을 암호화하는 것보다 효율적이기 때문에 대칭키르르 사용한다. 복호화는 private key를 가지고 있는 서버만 가능하다. CA-signed 인증서 발급 과정 모식도\n[Picture 12] CA-signed 인증서 발급 과정 모식도\nSelf-signed 인증서 발급 과정 모식도\n[Picture 13] Self-signed 인증서 발급 과정 모식도\n","date":"2022-08-27","permalink":"https://leeleelee3264.github.io/post/2022-08-27-digital-certificate-part-final/","tags":["Infra"],"title":"Digital certificate 적용하기"},{"content":"\noauth2를 사용하고 있는 Myinfo API 를 사용하는 connector client를 Python/Django로 구현한다.\n[github]\n[api document]\n[quick start]\nIndex\nMyinfo란? 프로젝트 목표 프로젝트 구현 프로젝트 회고 Myinfo란? 싱가폴 Mydata 서비스 정부가 주도한 Mydata 서비스가 몇 개의 나라에 있다고 하는데, 싱가폴 정부의 Singpass는 그 중에서도 모범사례로 뽑힌다고 한다. Singpass는 싱가포르의 15세 이상의 인구 중 97% 가 쓰고 있는 아주 활발한 서비스이다.\nSingpass에 있는 여러가지 서비스 중 Myinfo는 Person Data를 제공하는 서비스로, 한국의 카카오나 네이버 아이디 처럼 ouath2 로그인과 회원가입을 할 수 있다. [Picture 1] 에서 singpass에 대해서 조금 더 자세히 살펴볼 수 있다.\n[Picture 1] Introduce Singpass\nMyinfo oauth2 Myinfo는 [Picture 2] 와 같은 oauth2 구조를 가진다.\n[Picture 2] Myinfo oauth2 구조\nResource Owner Myinfo 사용자 Application 내가 구현하는 connector로, Myinfo 사용자의 데이터를 사용하는 주체 Identify Providers / Service Authorization Platform 인증서버 사용자의 인증정보와 권한 정보를 소유한 서버 Singpass 로그인 페이지 제공 Resource Server 사용자 데이터를 소유한 서버 인증 서버에 로그인 성공 후 접근 Myinfo Resource API 권한 인증 요청 [authorise api] GET /v3/authorise Singpass 로그인 페이지를 불러온다. 로그인 후 Singpass에서 사용자의 데이터를 불러오는 것에 대한 동의를 진행한다. 사용자가 동의했을 경우 authcode를 return 한다. Token 요청 [token api] POST /v3/token authocode를 사용하여 token을 요청한다. PKI를 사용하여 인증을 진행한다. 인증이 완료되면 token을 return 한다. 사용자 정보 요청 [person api] GET /v3/person/{sub} token 속의 access token을 사용하여 사용자 정보를 요청한다. 사용자 정보를 return 한다. 프로젝트 목표 Singpass가 제공하는 [Java]와 [node.js] 버전의 client connector 처럼 이번에 프로젝트로 python 버전의 connector를 만들었다. 아예 하나의 REST API 형태로 제공을 하기 위해 프레임워크로 Django를 선택했다.\n프로젝트 목표 프로젝트를 진행하면서 이루고자 한 목표는 아래와 같다. 대부분의 토이 프로젝트가 제대로 정리가 되어있지 않거나 코드가 엉망으로 짜여질 때가 많아서 이번에는 처음부터 확실하게 목표를 설정했다.\nCode Quality\nDDD 아키텍처로 서버를 구현한다. 최소 2회의 리팩토링을 진행한다. python lint(flake8, pylint, mypy)를 사용하여 최대한 python style을 고수한다. Pipenv를 사용해서 python 패키지를 관리한다. Documentation\nGithub README를 작성한다. API document를 작성한다. Project에 대한 블로그 포스팅을 작성한다. Dev Stack stack info Backend Language Python Backend Framework Django Code Architecture Domain Driven Desgin Python Package Managment Pipenv API Security PKI Version Control Github API Document GitBook 프로젝트 구현 Make Request Myinfo oauth2 구조를 반영하여, connector 서버의 호출 flow를 [Picture 3] 같이 설계했다.\n[Picture 3] connector 서버 호출 flow\nStep 1: Get myinfo login url Request GET /users/me/external/myinfo-redirect-login\ncurl -i -H 'Accept: application/json' \u0026lt;http://localhost:3001/user/me/external/myinfo-redirect-login\u0026gt; Response { \u0026quot;message\u0026quot;: \u0026quot;OK\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;https://test.api.myinfo.gov.sg/com/v3/authorise?client_id=STG2-MYINFO-SELF-TEST\u0026amp;attributes=name,dob,birthcountry,nationality,uinfin,sex,regadd\u0026amp;state=eb03c000-00a3-4708-ab30-926306bfc4a8\u0026amp;redirect_uri=http://localhost:3001/callback\u0026amp;purpose=python-myinfo-connector\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;eb03c000-00a3-4708-ab30-926306bfc4a8\u0026quot; } } Step 2: Browse myinfo login url Request curl \u0026lt;https://test.api.myinfo.gov.sg/com/v3/authorise?client_id=STG2-MYINFO-SELF-TEST\u0026amp;attributes=name,dob,birthcountry,nationality,uinfin,sex,regadd\u0026amp;state=eb03c000-00a3-4708-ab30-926306bfc4a8\u0026amp;redirect_uri=http://localhost:3001/callback\u0026amp;purpose=python-myinfo-connector\u0026gt; Response [Picture 4] Myinfo Login Page\nStep 3: Login and check agree terms Login Check Login page in [Picture 5]\nAgree Terms [Picture 5] Myinfo Terms Agreement Page\nStep 4: Callback API get called by Myinfo Myinfo에서 Request를 하는 Step이다.\n로그인을 하고 terms에 동의를 하면 Myinfo에서 connector client의 callback API를 호출해 authcode를 넘겨준다.\nRequest GET /callback?{code}\ncurl \u0026lt;http://localhost:3001/callback?code=8932a98da8720a10e356bc76475d76c4c628aa7f\u0026amp;state=e2ad339a-337f-45ec-98fa-1672160cf463\u0026gt; Response [Picture 6] Callback Response Page\nFinal Step: Get Person data 자동화된 Step이다.\nCallback API의 응답인 callback 페이지는 자동으로 connector client의 person data API를 호출하도록 했다. 해당 API가 Myinfo에서 사용자 정보를 가져오는 마지막 단계이다.\nRequest GET /users/me/external/myinfo\ncurl -i -H 'Accept: application/json' \u0026lt;http://localhost:3001/user/me/external/myinfo\u0026gt; Response { \u0026quot;message\u0026quot;: \u0026quot;OK\u0026quot;, \u0026quot;sodata\u0026quot;: { \u0026quot;regadd\u0026quot;: { \u0026quot;country\u0026quot;: { \u0026quot;code\u0026quot;: \u0026quot;SG\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;SINGAPORE\u0026quot; }, \u0026quot;unit\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, \u0026quot;street\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;ANCHORVALE DRIVE\u0026quot; }, \u0026quot;lastupdated\u0026quot;: \u0026quot;2022-07-14\u0026quot;, \u0026quot;block\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;319\u0026quot; }, \u0026quot;source\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;postal\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;542319\u0026quot; }, \u0026quot;classification\u0026quot;: \u0026quot;C\u0026quot;, \u0026quot;floor\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;38\u0026quot; }, \u0026quot;type\u0026quot;: \u0026quot;SG\u0026quot;, \u0026quot;building\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;\u0026quot; } }, \u0026quot;dob\u0026quot;: \u0026quot;1988-10-06\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;M\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;ANDY LAU\u0026quot;, \u0026quot;birthcountry\u0026quot;: \u0026quot;SG\u0026quot;, \u0026quot;nationality\u0026quot;: \u0026quot;SG\u0026quot;, \u0026quot;uinfin\u0026quot;: \u0026quot;S6005048A\u0026quot; } } PKI Digital Signature Myinfo는 PKI Digital Signature를 필요로 한다. 해당 문서에서는 python에서 구현을 할 때 PKI를 사용하는 방법만을 다루기 때문에 PKI에 대한 더 자세한 설명은 링크로 첨부하겠다. [LeeLee- Digital Certificate]\npython 패키지로는 *jwcrypto*와 Crypto를 사용했다.\nPKI 시나리오 connector client private key\n[myinfo token api]를 호출할 때 [myinfo person api]를 호출 할 때 [myinfo person api] 응답 decrypt 할 때 myinfo에서 connector client의 public key로 응답을 암호화 했기 때문 myinfo public key\nmyinfo token api 응답 verify 할 때 myinfo에서 myinfo의 private key로 응답을 암호화 했기 때문 myinfo person api 응답 verify 할 때 myinfo에서 myinfo의 private key로 응답을 암호화 했기 때문 public, privateKey 불러오기 1 2 3 4 5 6 7 8 9 10 11 from jwcrypto import jwk PrivateKey = jwk.JWK PublicKey = jwk.JWK def _get_key(self, key: str) -\u0026gt; Union[PrivateKey, PublicKey]: encode_key = key.encode(\u0026#39;utf-8\u0026#39;) key_dict = jwk.JWK.from_pem(encode_key) return key_dict connector client private key로 서명하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import base64 from Crypto.Hash import SHA256 from Crypto.PublicKey import RSA from Crypto.Signature import PKCS1_v1_5 Signature = str def _sign_on_raw_header( self, base_string: str, private_key: str, ) -\u0026gt; Signature: digest = SHA256.new() digest.update( base_string.encode(\u0026#39;utf-8\u0026#39;), ) pk = RSA.importKey(private_key) signer = PKCS1_v1_5.new(pk) signature = str(base64.b64encode(signer.sign(digest)), \u0026#39;utf-8\u0026#39;) return signature connector client private key로 응답 decrypt 하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import json from jwcrypto import ( jwe, jwk, ) PrivateKey = jwk.JWK def _decrypt( self, encrypted_payload: str, key: PrivateKey, ) -\u0026gt; DecryptedPersonData: params = self._get_decrypt_params(encrypted_payload) encryption = jwe.JWE() encryption.deserialize(params, key) data = encryption.plaintext data_str = json.loads(data) return data_str myinfo public key로 응답 verify 하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import json from jwcrypto import jwk PublicKey = jwk.JWK DecodedPersonData = dict def _decode( self, encoded_payload: str, key: PublicKey, ) -\u0026gt; DecodedPersonData: token = jwt.JWT() token.deserialize(jwt=encoded_payload, key=key) data = token.claims data_dict = json.loads(data) person = DecodedPersonData(**data_dict) return person 프로젝트 회고 문서화 정해둔 목표를 잘 이행한 기분이 들어서 뿌듯했다. 또한 항상 미흡했던 문서화를 꼼꼼하게 해 둔 거 같아 만족스럽다. 하지만 문서화를 하는 과정에서 어떻게 내가 말하고자 하는 바를 더 깔끔하게 글로 옮길 수 있을까 고민을 많이 했고, 아직도 부족한 부분이 많이 보인다. 리팩토링 코드 또한 2번 리팩토링을 진행했지만 포스팅을 위해서 다시 코드를 보니 또 리팩토링 해야겠다는 생각이 든다. 프로젝트를 할 때 1,2번의 리팩토링을 하고 프로젝트가 끝나고 2~3달 지나서 리팩토링을 1 번 진행하면 좋을 거 같다. Boilerplate 어떤 프로젝트를 하더라도 프레임워크 setting을 하는데 초기 시간을 많이 소요하는데, 앞으로 Django로 계속 프로젝트를 진행할 예정이라면 pre-setting이 어느 정도 되어있는 Django Boilerplate 를 만들어야겠다.\n","date":"2022-07-23","permalink":"https://leeleelee3264.github.io/post/2022-07-23-project-myinfo-connector-python/","tags":["Project"],"title":"Python으로 Myinfo oauth2 client connector 구현하기"},{"content":"\n간단한 프로파일링을 할 수 있는 profiler를 Python decorator로 구현한다.\nIndex\nprofiler 구현 계기 profiler 구현 개선해야 하는 부분 profiler 구현 계기 Django 환경에서 unittest를 하며 간단하게 퍼포먼스를 측정하고 싶었다. 아주 간단하게 프로파일링을 하면 되기 때문에 Middleware 같은 것은 만들지 않았다. 대신에 Python의 decorator로 만들었다. 앞으로 더 심화되고 유익한 정보를 포함하고 있는 Profiler를 decorator 형식으로 만들면 유용할 것 같다.\n구현한 profiler\n메모리 사용량을 보기 위한 ram_profiler 함수에서 호출된 쿼리와 쿼리 실행시간을 보기 위한 query_profiler 함수 실행시간 을 보기 위한 elapsed_timer profiler 구현 ram_profiler 이 프로파일러를 구현하다가 알게 된 사실인데 Python에서 메모리나 CPU 사용량을 보려면 psutill builtin 패키지를 사용하는 경우가 많았다.\ndecorator는 함수 호출 전과 후의 메모리 사용량을 가져와, 함수가 호출이 되면서 얼추 어느 정도의 메모리를 사용했는지 비교할 수 있도록 한다.\nram_profiler 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def ram_profiler(fn): \u0026#34;\u0026#34;\u0026#34; 퍼포먼스 체크를 위한 메모리 프로파일러 메모리 사용량을 측정할 함수 위에 @ram_profiler 를 추가해주시면 됩니다. 체크하는 메모리는 아래와 같습니다. 1) 그냥 현재 memory usage 정보를 그대로 가져오는 경우 2) 현재 process id를 통해 해당 프로세스의 memory usage를 정확하게 비교하는 경우 ex) @ram_profiler def pre_allot_offering(offering: Offering): \u0026#34;\u0026#34;\u0026#34; def inner(*args, **kwargs): print(\u0026#39;\\n\u0026#39;) print(\u0026#34;===== memory usage check =====\u0026#34;) memory_usage_dict = dict(psutil.virtual_memory()._asdict()) memory_usage_percent = memory_usage_dict[\u0026#39;percent\u0026#39;] print(f\u0026#34;BEFORE CODE :: memory_usage_percent: {memory_usage_percent}%\u0026#34;) pid = os.getpid() current_process = psutil.Process(pid) current_process_memory_usage_as_kb = current_process.memory_info()[0] / 2. ** 20 print(f\u0026#34;BEFORE CODE :: Current memory KB : {current_process_memory_usage_as_kb: 9.3f} KB\u0026#34;) target_func = fn(*args, **kwargs) print(\u0026#34;==\u0026#34; * 20) print(f\u0026#34;== {fn.__name__} memory usage check ==\u0026#34;) memory_usage_dict = dict(psutil.virtual_memory()._asdict()) memory_usage_percent = memory_usage_dict[\u0026#39;percent\u0026#39;] print(f\u0026#34;AFTER CODE :: memory_usage_percent: {memory_usage_percent}%\u0026#34;) pid = os.getpid() current_process = psutil.Process(pid) current_process_memory_usage_as_kb = current_process.memory_info()[0] / 2. ** 20 print(f\u0026#34;AFTER CODE :: Current memory KB : {current_process_memory_usage_as_kb: 9.3f} KB\u0026#34;) print(\u0026#39;\\n\u0026#39;) return target_func return inner ram_profiler 결과 ===== memory usage check ===== BEFORE CODE :: memory_usage_percent: 79.7% BEFORE CODE :: Current memory KB : 197.250 KB ======================================== == pre_allot_offering memory usage check == AFTER CODE :: memory_usage_percent: 79.7% AFTER CODE :: Current memory KB : 197.312 KB query_profiler decorator는 쿼리를 관리하는 context를 임포트 해와서 타겟 함수를 실행하면서 호출되었던 쿼리들을 캡처해두었다가 함수가 끝이 나면 보여준다. ORM에서 실제로 어떤 쿼리가 실행되는지 봐야 할 때, 조건문에 따라 쿼리가 달라질 때, N + 1 쿼리를 잡아 낼 때 사용하기 좋다.\nquery_profiler 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def query_profiler(fn): \u0026#34;\u0026#34;\u0026#34; 호출이 된 query를 확인하기 위한 프로파일러 호출 된 query를 확인할 함수 위헤 @query_profiler 를 추가해주시면 됩니다. ex) @query_profiler def pre_allot_offering(offering: Offering): \u0026#34;\u0026#34;\u0026#34; def inner(*args, **kwargs): print(\u0026#39;\\n\u0026#39;) print(f\u0026#34;===== {fn.__name__} called query check =====\u0026#34;) with CaptureQueriesContext(connection) as context: target_func = fn(*args, **kwargs) for index, query in enumerate(context.captured_queries): sql = query.get(\u0026#39;sql\u0026#39;) time = query.get(\u0026#39;time\u0026#39;) print(f\u0026#39;CALLED QUERY :: [{index}]\u0026#39;) print(f\u0026#39;CALLED QUERY :: query: {sql}\u0026#39;) print(f\u0026#39;CALLED QUERY :: executed time: {time}\u0026#39;) print(\u0026#34;=====\u0026#34;) return target_func return inner query_profiler 결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ===== pre_allot_offering called query check ===== CALLED QUERY :: [0] CALLED QUERY :: query: SAVEPOINT `s4377609600_x5` CALLED QUERY :: executed time: 0.001 ===== CALLED QUERY :: [1] CALLED QUERY :: query: SELECT `offering_subscription`.`id` # 실제 쿼리는 블라인드 CALLED QUERY :: executed time: 0.00 ===== CALLED QUERY :: [2] CALLED QUERY :: query: UPDATE `offering_subscription` SET # 실제 쿼리는 블라인드 CALLED QUERY :: executed time: 0.003 ===== CALLED QUERY :: [3] CALLED QUERY :: query: SELECT `offering_subscription`.`id`, # 실제 쿼리는 블라인드 ===== CALLED QUERY :: [4] CALLED QUERY :: query: SELECT `offering_subscription`.`id`, # 실제 쿼리는 블라인드 CALLED QUERY :: executed time: 0.002 ===== CALLED QUERY :: [5] CALLED QUERY :: query: UPDATE `offering_subscription` SET # 실제 쿼리는 블라인드 CALLED QUERY :: executed time: 0.002 ===== CALLED QUERY :: [6] CALLED QUERY :: query: RELEASE SAVEPOINT `s4377609600_x5` CALLED QUERY :: executed time: 0.001 ===== elapsed_timer decorator는 함수의 시작시간과 끝나는 시간을 측정하여 함수 실행시간이 어느정도인지를 계산한다.\nelapsed_timer 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def elapsed_timer(fn): \u0026#34;\u0026#34;\u0026#34; 퍼포먼스 체크를 위한 실행 시간 측정 타이머 실행 시간을 측정할 함수 위에 @elapsed_timer 를 추가해주시면 됩니다. 퍼포먼스 테스트가 끝나면 지워주시길 바랍니다. ex) @elapsed_timer def pre_allot_offering(offering: Offering): \u0026#34;\u0026#34;\u0026#34; def inner(*args, **kwargs): print(\u0026#39;\\n\u0026#39;) print(f\u0026#34;===== {fn.__name__} elapsed time check =====\u0026#34;) start = perf_counter() target_func = fn(*args, **kwargs) end = perf_counter() print(f\u0026#39;ELAPSED :: total: start: {start} sec - end: {end} sec\u0026#39;) duration = end - start print(f\u0026#39;ELAPSED :: duration: {duration} sec\u0026#39;) print(f\u0026#39;ELAPSED :: duration in minutes : {str(timedelta(seconds=duration))} mins\u0026#39;) print(\u0026#39;\\n\u0026#39;) return target_func return inner elapsed_timer 결과 1 2 3 4 ===== pre_allot_offering elapsd time check ===== ELAPSED :: total: start: 8.705878 sec - end: 8.72449375 sec ELAPSED :: duration: 0.018615750000000375 sec ELAPSED :: duration in minutes : 0:00:00.018616 mins (builtin) @profiler 메모리를 프로파일링하는 것에 한정한다면 Python에서 builtin으로 제공하는 memory_profiler 라는 것이 있다. 패키지 안의 @profiler 데코레이터를 사용하면 함수 안에서 코드가 실행이 될 때 한 줄 한 줄 얼마의 메모리를 사용했는지를 볼 수 있다.\nORM을 포함하고 있는 코드에도 사용을 해보려 했는데 recursive 하게 동작을 하다가 스택이 터져서 사용을 할 수 없었다. 함수가 한 줄 씩 호출되면서 메모리 사용량을 보기에는 정말 좋은 데코레이터 처럼 보이는데 꼭 다음에 써보도록 해야겠다.\n@profiler 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from memory_profiler import profile @profile def main_func(): import random arr1 = [random.randint(1,10) for i in range(100000)] arr2 = [random.randint(1,10) for i in range(100000)] arr3 = [arr1[i]+arr2[i] for i in range(100000)] del arr1 del arr2 tot = sum(arr3) del arr3 print(tot) if __name__ == \u0026#34;__main__\u0026#34;: main_func() @profiler 결과 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 Line # Mem usage Increment Line Contents ================================================ 3 37.0 MiB 37.0 MiB @profile 4 def main_func(): 5 37.0 MiB 0.0 MiB import random 6 37.6 MiB 0.3 MiB arr1 = [random.randint(1,10) for i in range(100000)] 7 38.4 MiB 0.3 MiB arr2 = [random.randint(1,10) for i in range(100000)] 8 39.9 MiB 0.5 MiB arr3 = [arr1[i]+arr2[i] for i in range(100000)] 9 39.9 MiB 0.0 MiB del arr1 10 38.0 MiB 0.0 MiB del arr2 11 38.0 MiB 0.0 MiB tot = sum(arr3) 12 37.2 MiB 0.0 MiB del arr3 13 37.2 MiB 0.0 MiB print(tot) 개선해야 하는 부분 Python의 Decorator는 함수의 시작 - 끝 부분에 추가 action을 할 수 있게 해주는 Wrapper이다. 함수 중간중간에 프로파일링을 해야 한다면 다른 방법으로 접근을 해야 할 것 같다.\n","date":"2022-06-29","permalink":"https://leeleelee3264.github.io/post/2022-06-30-python-profiler-decorator/","tags":["Backend"],"title":"Python decorator로 간단한 profiler 구현하기"},{"content":"\nPKI의 certificate에 대해서 다룬다.\nIndex\n인증서에 대해 잘못 알고 있던 점들 인증서의 종류 인증서와 관련된 개념 인증서에 대해 잘못 알고 있던 점들 인증서의 종류 적절하지 않은 인증서 분류 web에서 HTTPS 통신을 하기 위해 사용하는 web secure용 SSL 인증서 digital signature(디지털 서명) 를 하기 위한 code signing 인증서 디지털 서명을 해야 했기 때문에 code signing 인증서를 발급받으려 했다. 하지만 SSL 인증서도 디지털 서명을 할 수 있었고, 목표인 server to server 커뮤니케이션에서 사용하는 신원 보장용 디지털 서명을 하기 위해서는 SSL 인증서를 발급해야 했다.\n[Picture 1] 적절하지 않은 인증서 분류\n적절한 인증서 분류 SSL 인증서는 웹사이트, 정확히 말하면 브라우저에 한정해서 사용한다고 생각했는데 이는 너무 한정적인 생각이었다. SSL 인증서는 client와 server가 (browser to server / server to server) 데이터를 주고 받을 때 암호화를 하기 위해 쓰이기 때문에 브라우저에 한정적이지 않다.\n결국 인증서는 [Picture 2] 처럼 분류를 해야 한다.\n[Picture 2] 적절한 인증서 분류\nCode Signing 인증서 발급받으려 했던 code signing 인증서는 어플리케이션에 서명을 해서 해당 어플리케이션 publisher의 신원을 보장하는데 사용하기 때문에 내가 필요했던 server to server 커뮤니케이션에서 사용되는 인증서가 아니다.\ncode signing 인증서로 어플리케이션에 서명을 하게 되면 [Picture 3] 와 같이 사용자에게 어플리케이션 publisher 에 대한 정보가 추가로 제공이 된다.\n[Picture 3] code signing 인증서로 서명한 application\nCSR 생성하기 모든 SSL 인증서는 domain validation을 한다. 이 생각에 사로잡혀서 Root CA가 서명한 인증서를 발급받기 위해 제출해야 하는 CSR는 인증서가 사용이 될 서버에서 만들어야 한다고 생각했다.\n예를 들어 leelee.me 이라는 루트 도메인에서 사용하는 인증서라고 했을 때 leelee.me 도메인을 호스팅하는 서버에서 CSR을 생성해야 한다고 생각한 것이다. 하지만 CSR을 다른 서버에서 생성했다면, CSR을 생성할 때 함께 만든 private key를 인증서를 사용할 서버로 옮기면 된다.\n인증서의 종류 SSL Certificate VS Code Signing Certificate 공통점\nX.509 형태의 디지털 인증서다. PKI 형식을 사용한다. 두 인증서가 없다면 사용자에게 보안 경고가 띄워진다. 발급하기 전에 CA에서 발급요청자를 검증한다. end user들이 해킹등의 사이버 범죄에 노출되는 것을 방지하기 위해 사용된다. 차이점\nSSL Certificate은 두 시스템에서 오고가는 data를 암호화한다. Code Signing Certificate은 소프트웨어 자체를 hash \u0026amp; sign 한다. 모든 코드에 디지털 서명을 한 것과 마찬가지이며 만약 중간에서 누가 코드를 수정한다면 해시값이 변경이 되어 end user가 코드를 다운받기 전에 alert를 띄워 사전에 설치를 못 하도록 막는다. [Picture 4] 인증서 다이어그램\nSSL Certificate SSL Certificate는 크게 2가지 기준으로 분류할 수 있다.\n검증히려는 대상 커버하는 도메인의 개수 검증하려는 대상 검증 대상에 따라서 암호화하는 방식이 달라지거나 하지 않는다. 따라서 저렴하게 발급받은 DV와 비싸게 발급받은 EV가 결국 보안의 관점에서는 큰 차이가 없다.\n하지만 검증받은 대상의 identiy가 다르기 때문에 DV는 작은 서비스에서 사용하기가 용이하고 그 외에 e-commerce나 중요한 정보를 주고 받아야 하는 서비스의 경우에는 다른 인증서를 써야 한다.\nDomain Validation 도메인 소유권을 확인한다. 손쉽게 발급받을 수 있다. (최대 1일) 가장 많이 사용되는 SSL Certificate의 형태다. Let’s encrypt에서 발급하는 인증서도 DV로, OV나 EV 처럼 다른 인증을 받을 때는 사용할 수 없다. Organization Validation 도메인 소유권 + Organization 존재를 확인한다. 회사 같은 경우, 실제로 존재하는 회사인지를 확인하기 위해 관련 서류를 제출하기도 한다. 발급하는데 몇 시간 또는 며칠 정도가 소요된다. Extended Validation 도메인 소유권 + Organization 존재 확인 + 물리적인 추가 절차를 확인한다. SSL certification industry’s governing consortium 가이드라인을 준수해야 하는 등 발급 절차가 복잡하다. 커버하는 도메인의 개수 인증서에는 도메인이라는 말이 자주 등장하게 된다. 하지만 도메인이라는 단어 자체가 뜻하는 의미가 모호할 수 있기 때문에 혼선방지 차원에서 인증서에서는 FQDN 이라는 단어를 더 선호한다.\nFQDN은 Fully-Qualified Domain Name 의 약자로 도메인 전체 이름을 표기하는 방식을 뜻한다.\nFQDN 예시\n# 아래는 서로 동일한 도메인이다. www.leelee.co.kr leelee.co.kr www.sub.leelee.co.kr # 아래는 서로 다른 FQDN 이다. www.leelee.co.kr leelee.co.kr Single Domain 단 하나의 FQDN을 커버한다. Multiple Domain 여러개의 FQDN을 커버한다. 인증서를 등록할 때 SAN (Subject Alternative Name) 항목에 다수의 도메인을 입력한다. Wildcard Domain 하나의 Root Domain과 무제한의 서브도메인을 커버한다. wildcard는 하나의 전체도메인을 입력하지 않기 때문에 FQDN이라 하지 않았다. CA 업체에서는 비용에 따라서 커버하는 서브도메인 개수에 제한을 두기도 한다. * 을 사용해서 도메인을 커버한다. 커버하는 도메인 예시\n# Singple Certificate www.leelee.co.kr # Multi-Domain Certificate www.leelee.co.kr leelee.co.kr www.sub.leelee.co.kr # Wildcard Certificate *.leelee.co.kr 인증서와 관련된 개념 PKI PKI는 Public Key Infrastructure 의 약자로 공개키 기반구조라고 하며 디지털 인증서를 생성, 관리, 배포, 사용, 저장 및 파기, 공개키 암호화의 관리에 필요한 정책 등을 뜻한다. PKI는 아래의 항목을 전체로 하고 있다.\n비대칭 키 알고리즘을 이용한다. Private key, Public key pair 를 생성한다. Private key는 개인만 소유하며 밖으로 공개해서는 안된다. Public key는 공개하는 키로, 누구에게든 공개해도 된다. 비대칭 키 알고리즘 Private key, Public key 두 개의 키를 사용한다. 이처럼 Encryption(암호화)와 Decryption(복호화)에 두 개의 다른 키를 쓰기 때문에 비대칭 키라고 한다. 대표적인 알고리즘으로는 RSA가 있다.\n적용 시나리오 Public key를 이용해 암호화 : 데이터 보안 사용자 B가 사전에 공유받은 사용자 A의 public key를 이용하여 데이터를 암호화한다. 사용자 A의 public key로 암호화된 데이터는 오직 사용자 A의 private key로 복호화 할 수 있다. 사용자 A의 private key는 사용자 A만 소유하고 있기 때문에 사용자 B는 사용자 A만 볼 수 있는 데이터를 전송하게 된 것이다. [Picture 5] Public key를 이용한 암호화\nPrivate key를 이용해 암호화 : 신원인증 사용자 A의 private key로 암호화 된 데이터는 사용자 A의 public key를 이용해야만 복호화를 할 수 있다. 데이터가 사용자 A의 public key로 복호화가 안된다면 사용자A가 보냈다는 것을 인증할 수 없다. 사용자 A의 public key로 데이터를 복호화할 수 있다면 사용자 A가 보냈다는 것을 인증할 수 있다. [Picture 6] Private key를 이용한 암호화\n해커가 암호화된 데이터를 도청할 경우 사용자 A의 private key가 없기 때문에 해커가 중간에서 데이터를 복호화ㅊ할 수 없다. [Picture 7] 해킹 시도\nPKI에서 가능한 두 가지 방식의 네트워크 보안 public key를 이용해 암호화 하면 원하는 상대방에게만 데이터를 공개할 수 있다. from 사용자 B → to 사용자 A private key를 이용해 암호화 하면 신원 인증을 할 수 있다. from 사용자 A → to 사용자 B X.509 X.509는 디지털 인증서 생성 관련 국제 표준을(format)을 의미한다. X.509를 사용하는 네트워크 노드들은 전세계적으로 약속된 x.509 국제 표준을 방식으로 디지털 ID를 생성해 서로의 신원을 증명할 수 있다.\nX.509는 인터넷의 다양한 분야에서 신원 확인을 위해 광범위하게 사용되고 있는 가장 유명한 디지털 신원 증명 방식이다.\nX.509 version 3 인증서 양식 [Picture 8] X.509 인증서 양식\nKey usage extension 인증서에 포함되어있는 public key의 목적을 나타낸다. Key usage extension을 설정해 public key의 사용처를 제한할 수 있다.\nKey usage extension 예시\n인증서가 서명을 하거나 signature를 검증하기 위해 사용된다면 Key usage extension으로 Digital signature와 Non-repudication 를 설정한다. 인증서가 key 관리를 위해서만 사용이 된다면 key encipherment를 설정한다. [Picture 9] Key usage extension 종류\nExtended key usage Key usage extension이 기본적인 인증서의 사용 목적(purpose)를 나타내는 것이라면 Extended key usage는 인증서의 additional한 사용 목적을 나타낸다. 보통 Extended key usage는 end entity의 인증서에만 표시가 된다.\nExtended key usage 예시\ncritical이라면 인증서는 설정되어있는 용도로만 사용을 해야 한다. 해당 인증서를 다른 용도로 사용 했을 경우에는 CA 정책에 위반된다. non-critical 이라면 설정되어있는 용도 외의 다른 용도로 사용 했을 경우에도 CA의 제한에 걸리지 않는다. 또한 다수의 kye/certificate을 가지고 있는 entity라면 맞는 key/certificate를 찾는데에도 사용이 될 수 있다. [Picture 10] Extend key usage extension 종류\nCSR Certificate Signing Request의 약자이다. CA에 인증서를 서명해달라고 요청할 때 사용이 된다. 인증서 발급할 때만 사용이 되고, 인증서가 발급된 후에는 별도로 사용 되지 않는다. Private Key PKI의 핵심이 되는 비밀키이다. 만료 기간이 별도로 존재하지 않는다. Public Key PKI의 또 다른 핵심이 되는 공개키이다. Public Key라고 따로 파일이 존재하기 보다는 Certificate에 포함이 되어있다. 때문에 public key와 certificate을 혼용해서 쓴다. 만료 기간이 별도로 존재하지 않는다. Certificate public key와 각종 정보를 담고 있는 인증서로, x.509 형식으로 되어있다. 만료 기간이 존재한다. 때문에 인증서가 만료되면 새로운 인증서를 발급받아야 한다. PKI File Extension PEM (Privacy Enhanced Mail) 형식 은 가장 흔하게 사용되는 X.509 인증서 형식인데 .crt, .pem, .cer, .key 확장자 모두가 PEM 형식이다. \u0026mdash;\u0026ndash;BEGIN CERTIFICATE\u0026mdash;\u0026ndash; 로 시작한다.\n.cert *.crt Certificate를 위한 확장자다. Base64 encoded X.509 certificate DER encoded X.509 certificate 해당 확장자들은 Private key를 지원하지 않는다. .key Private key 확장장다. .pem Certificate를 위한 확장자다. .crl Certificate Revoke List를 위한 확장자다. Certificate Revoke List는 폐기된 인증서의 목록이며, CA는 CRL을 통해 폐기된 인증서를 관리한다. .csr Certificate Singing Request를 위한 확장자다. .der Certificate을 위한 인증서 확장자인데, DER encoded X.509 Certificate에 한정된다. 해당 확장자는 Private key를 지원하지 않는다. 보통의 인증서들과 달리 ----BEGIN CERTIFICATE----- 로 시작하지 않는다. Java contexts에서 자주 사용이 된다. .der 인증서 예시\n3082 07fd 3082 05e5 a003 0201 0202 1068 1604 dff3 34f1 71d8 0a73 5599 c141 7230 0d06 092a 8648 86f7 0d01 010b 0500 3072 310b 3009 0603 5504 0613 0255 5331 0e30 0c06 0355 0408 0c05 5465 7861 7331 1030 0e06 0355 0407 0c07 486f 7573 746f 6e31 1130 0f06 0355 040a 0c08 5353 4c20 436f 7270 312e 302c 0603 5504 030c 2553 534c 2e63 6f6d 2045 5620 5353 4c20 496e 7465 726d 6564 6961 7465 2043 4120 5253 4120 ","date":"2022-06-15","permalink":"https://leeleelee3264.github.io/post/2022-06-15-digital-certificate-part-one/","tags":["Infra"],"title":"Digital certificate"}]